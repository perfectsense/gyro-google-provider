/*
 * Copyright 2019, Perfect Sense, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package gyro.google.compute;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import com.google.cloud.compute.v1.NetworkInterface;
import gyro.core.resource.Diffable;
import gyro.core.resource.Output;
import gyro.core.validation.Required;
import gyro.google.Copyable;

public class InstanceNetworkInterface extends Diffable implements Copyable<NetworkInterface> {

    private NetworkResource network;
    private SubnetworkResource subnetwork;
    private String networkIp;
    private List<InstanceAccessConfig> accessConfig;
    private List<InstanceAliasIpRange> aliasIpRange;
    private String fingerprint;
    private String name;

    /**
     * Network for this instance. If neither the network or subnetwork is specified, the default network ``global/networks/default`` is used and if the network is not specified but the subnetwork is specified, the network is inferred.
     *
     * @resource gyro.google.compute.NetworkResource
     */
    @Required
    public NetworkResource getNetwork() {
        return network;
    }

    public void setNetwork(NetworkResource network) {
        this.network = network;
    }

    /**
     * Subnetwork for this instance. If the network resource is in legacy mode, do not specify this field. If the network is in auto subnet mode, specifying the subnetwork is optional. If the network is in custom subnet mode, specifying the subnetwork is required.
     *
     * @resource gyro.google.compute.SubnetworkResource
     */
    public SubnetworkResource getSubnetwork() {
        return subnetwork;
    }

    public void setSubnetwork(SubnetworkResource subnetwork) {
        this.subnetwork = subnetwork;
    }

    /**
     * An IPv4 internal IP address to assign for this network interface. If unspecified an unused internal IP is assigned.
     */
    public String getNetworkIp() {
        return networkIp;
    }

    public void setNetworkIp(String networkIp) {
        this.networkIp = networkIp;
    }

    /**
     * A list of access configurations for this interface. Currently, only ``NE_TO_ONE_NAT`` is supported. If unspecified this instance will have no external internet access.
     *
     * @subresource gyro.google.compute.InstanceAccessConfig
     */
    public List<InstanceAccessConfig> getAccessConfig() {
        if (accessConfig == null) {
            accessConfig = new ArrayList<>();
        }
        return accessConfig;
    }

    public void setAccessConfig(List<InstanceAccessConfig> accessConfig) {
        this.accessConfig = accessConfig;
    }

    /**
     * A list of alias IP ranges for this network interface. Can only specify this for network interfaces in VPC networks.
     *
     * @subresource gyro.google.compute.InstanceAliasIpRange
     */
    public List<InstanceAliasIpRange> getAliasIpRange() {
        if (aliasIpRange == null) {
            aliasIpRange = new ArrayList<>();
        }
        return aliasIpRange;
    }

    public void setAliasIpRange(List<InstanceAliasIpRange> aliasIpRange) {
        this.aliasIpRange = aliasIpRange;
    }

    /**
     * Fingerprint hash of contents stored in this network interface. Will be ignored when inserting an Instance or adding a NetworkInterface. An up-to-date fingerprint must be provided in order to update the NetworkInterface, otherwise the request will fail with HTTP error 412.
     */
    public String getFingerprint() {
        return fingerprint;
    }

    public void setFingerprint(String fingerprint) {
        this.fingerprint = fingerprint;
    }

    /**
     * Name of the network interface as generated by the server.
     */
    @Output
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String primaryKey() {
        return getNetwork().getSelfLink() != null ? getNetwork().getSelfLink() : getNetwork().getName();
    }

    @Override
    public void copyFrom(NetworkInterface model) {
        setName(model.getName());

        setNetwork(null);
        if (model.hasName()) {
            setNetwork(findById(NetworkResource.class, model.getNetwork()));
        }

        setSubnetwork(null);
        if (model.hasSubnetwork()) {
            setSubnetwork(findById(SubnetworkResource.class, model.getSubnetwork()));
        }

        if (model.hasFingerprint()) {
            setFingerprint(model.getFingerprint());
        }

        if (model.hasNetworkIP()) {
            setNetworkIp(model.getNetworkIP());
        }

        setAccessConfig(null);
        if (!model.getAccessConfigsList().isEmpty()) {
            List<InstanceAccessConfig> diffableAccessConfigs = model.getAccessConfigsList()
                .stream()
                .map(ac -> {
                    InstanceAccessConfig instanceAccessConfig = newSubresource(InstanceAccessConfig.class);
                    instanceAccessConfig.copyFrom(ac);

                    return instanceAccessConfig;
                })
                .collect(Collectors.toList());

            setAccessConfig(diffableAccessConfigs);
        }

        setAliasIpRange(null);
        if (!model.getAliasIpRangesList().isEmpty()) {
            List<InstanceAliasIpRange> diffableAliasIpRanges = model.getAliasIpRangesList()
                .stream()
                .map(ap -> {
                    InstanceAliasIpRange instanceAliasIpRange = newSubresource(InstanceAliasIpRange.class);
                    instanceAliasIpRange.copyFrom(ap);

                    return instanceAliasIpRange;
                })
                .collect(Collectors.toList());

            setAliasIpRange(diffableAliasIpRanges);
        }
    }

    public NetworkInterface copyTo() {
        NetworkInterface.Builder builder = NetworkInterface.newBuilder();

        if (getFingerprint() != null) {
            builder.setFingerprint(getFingerprint());
        }

        if (getName() != null) {
            builder.setName(getName());
        }

        if (getNetworkIp() != null) {
            builder.setNetworkIP(getNetworkIp());
        }

        if (getNetwork() != null) {
            builder.setNetwork(getNetwork().getSelfLink());
        }

        if (getSubnetwork() != null) {
            builder.setSubnetwork(getSubnetwork().getSelfLink());
        }

        if (!getAccessConfig().isEmpty()) {
            builder.addAllAccessConfigs(getAccessConfig().stream()
                .map(InstanceAccessConfig::copyTo)
                .collect(Collectors.toList()));
        }

        if (!getAliasIpRange().isEmpty()) {
            builder.addAllAliasIpRanges(getAliasIpRange().stream()
                .map(InstanceAliasIpRange::copyTo)
                .collect(Collectors.toList()));
        }

        return builder.build();
    }
}
